// Code generated by goyacc -o parser.go -p QL parser.y. DO NOT EDIT.

//line parser.y:2
/*
Copyright 2022 Huawei Cloud Computing Technologies Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package geminiql

import __yyfmt__ "fmt"

//line parser.y:18

import (
	"strconv"
)

func updateStmt(QLlex interface{}, stmt Statement) {
	QLlex.(*QLLexerImpl).UpdateStmt(stmt)
}

//line parser.y:32
type QLSymType struct {
	yys      int
	stmts    []Statement
	stmt     Statement
	str      string
	strslice []string
	integer  int64
	decimal  float64
	pair     Pair
	pairs    Pairs
}

const INSERT = 57346
const INTO = 57347
const USE = 57348
const SET = 57349
const CHUNKED = 57350
const CHUNK_SIZE = 57351
const AUTH = 57352
const HELP = 57353
const PRECISION = 57354
const TIMER = 57355
const DOT = 57356
const COMMA = 57357
const EQ = 57358
const IDENT = 57359
const INTEGER = 57360
const DECIMAL = 57361
const STRING = 57362
const RAW = 57363

var QLToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"INSERT",
	"INTO",
	"USE",
	"SET",
	"CHUNKED",
	"CHUNK_SIZE",
	"AUTH",
	"HELP",
	"PRECISION",
	"TIMER",
	"DOT",
	"COMMA",
	"EQ",
	"IDENT",
	"INTEGER",
	"DECIMAL",
	"STRING",
	"RAW",
}

var QLStatenames = [...]string{}

const QLEofCode = 1
const QLErrCode = 2
const QLInitialStackSize = 16

//line parser.y:289

//line yacctab:1
var QLExca = [...]int8{
	-1, 1,
	1, -1,
	-2, 0,
}

const QLPrivate = 57344

const QLLast = 57

var QLAct = [...]int8{
	37, 27, 21, 25, 49, 51, 52, 50, 11, 55,
	12, 13, 14, 15, 16, 17, 18, 19, 36, 35,
	39, 20, 46, 31, 33, 39, 29, 26, 24, 32,
	42, 28, 45, 24, 41, 40, 43, 44, 30, 34,
	38, 23, 22, 48, 47, 53, 54, 10, 9, 8,
	7, 6, 5, 4, 3, 2, 1,
}

var QLPact = [...]int16{
	4, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000, -1000,
	-1000, 16, 10, 9, -1000, 5, -1000, -1000, 12, -1000,
	10, -1000, 1, 3, -1000, -1000, 21, -1000, 19, 14,
	-1000, -1000, -1000, 11, -1000, -1000, 8, -1000, 17, 6,
	10, 9, -13, -1000, 8, 8, -12, -1000, -1000, -1000,
	-1000, -1000, -1000, -1000, -1000, -1000,
}

var QLPgo = [...]int8{
	0, 56, 55, 54, 53, 52, 51, 50, 49, 48,
	47, 2, 42, 41, 40, 0, 39, 38, 3, 31,
	1,
}

var QLR1 = [...]int8{
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	4, 3, 2, 2, 5, 6, 17, 7, 8, 9,
	10, 18, 18, 11, 11, 12, 12, 19, 19, 19,
	19, 20, 20, 15, 15, 14, 13, 16,
}

var QLR2 = [...]int8{
	0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	2, 2, 4, 2, 1, 2, 1, 1, 1, 2,
	1, 1, 3, 1, 2, 4, 2, 3, 3, 3,
	3, 1, 3, 1, 3, 3, 1, 1,
}

var QLChk = [...]int16{
	-1000, -1, -2, -3, -4, -5, -6, -7, -8, -9,
	-10, 4, 6, 7, 8, 9, 10, 11, 12, 13,
	5, -11, -12, -13, 17, -18, 17, -20, -19, 17,
	-17, 18, 17, -18, -16, 18, 15, -15, -14, 17,
	14, 15, 16, -11, -15, 15, 16, -18, -20, 17,
	20, 18, 19, -15, -15, 21,
}

var QLDef = [...]int8{
	0, -2, 1, 2, 3, 4, 5, 6, 7, 8,
	9, 0, 0, 0, 14, 0, 17, 18, 0, 20,
	0, 13, 23, 0, 36, 11, 21, 10, 31, 0,
	15, 16, 19, 0, 24, 37, 0, 26, 33, 0,
	0, 0, 0, 12, 0, 0, 0, 22, 32, 27,
	28, 29, 30, 25, 34, 35,
}

var QLTok1 = [...]int8{
	1,
}

var QLTok2 = [...]int8{
	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
}

var QLTok3 = [...]int8{
	0,
}

var QLErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

//line yaccpar:1

/*	parser for yacc output	*/

var (
	QLDebug        = 0
	QLErrorVerbose = true
)

type QLLexer interface {
	Lex(lval *QLSymType) int
	Error(s string)
}

type QLParser interface {
	Parse(QLLexer) int
	Lookahead() int
}

type QLParserImpl struct {
	lval  QLSymType
	stack [QLInitialStackSize]QLSymType
	char  int
}

func (p *QLParserImpl) Lookahead() int {
	return p.char
}

func QLNewParser() QLParser {
	return &QLParserImpl{}
}

const QLFlag = -1000

func QLTokname(c int) string {
	if c >= 1 && c-1 < len(QLToknames) {
		if QLToknames[c-1] != "" {
			return QLToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func QLStatname(s int) string {
	if s >= 0 && s < len(QLStatenames) {
		if QLStatenames[s] != "" {
			return QLStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func QLErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !QLErrorVerbose {
		return "syntax error"
	}

	for _, e := range QLErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + QLTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := int(QLPact[state])
	for tok := TOKSTART; tok-1 < len(QLToknames); tok++ {
		if n := base + tok; n >= 0 && n < QLLast && int(QLChk[int(QLAct[n])]) == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if QLDef[state] == -2 {
		i := 0
		for QLExca[i] != -1 || int(QLExca[i+1]) != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; QLExca[i] >= 0; i += 2 {
			tok := int(QLExca[i])
			if tok < TOKSTART || QLExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if QLExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += QLTokname(tok)
	}
	return res
}

func QLlex1(lex QLLexer, lval *QLSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = int(QLTok1[0])
		goto out
	}
	if char < len(QLTok1) {
		token = int(QLTok1[char])
		goto out
	}
	if char >= QLPrivate {
		if char < QLPrivate+len(QLTok2) {
			token = int(QLTok2[char-QLPrivate])
			goto out
		}
	}
	for i := 0; i < len(QLTok3); i += 2 {
		token = int(QLTok3[i+0])
		if token == char {
			token = int(QLTok3[i+1])
			goto out
		}
	}

out:
	if token == 0 {
		token = int(QLTok2[1]) /* unknown char */
	}
	if QLDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", QLTokname(token), uint(char))
	}
	return char, token
}

func QLParse(QLlex QLLexer) int {
	return QLNewParser().Parse(QLlex)
}

func (QLrcvr *QLParserImpl) Parse(QLlex QLLexer) int {
	var QLn int
	var QLVAL QLSymType
	var QLDollar []QLSymType
	_ = QLDollar // silence set and not used
	QLS := QLrcvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	QLstate := 0
	QLrcvr.char = -1
	QLtoken := -1 // QLrcvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		QLstate = -1
		QLrcvr.char = -1
		QLtoken = -1
	}()
	QLp := -1
	goto QLstack

ret0:
	return 0

ret1:
	return 1

QLstack:
	/* put a state and value onto the stack */
	if QLDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", QLTokname(QLtoken), QLStatname(QLstate))
	}

	QLp++
	if QLp >= len(QLS) {
		nyys := make([]QLSymType, len(QLS)*2)
		copy(nyys, QLS)
		QLS = nyys
	}
	QLS[QLp] = QLVAL
	QLS[QLp].yys = QLstate

QLnewstate:
	QLn = int(QLPact[QLstate])
	if QLn <= QLFlag {
		goto QLdefault /* simple state */
	}
	if QLrcvr.char < 0 {
		QLrcvr.char, QLtoken = QLlex1(QLlex, &QLrcvr.lval)
	}
	QLn += QLtoken
	if QLn < 0 || QLn >= QLLast {
		goto QLdefault
	}
	QLn = int(QLAct[QLn])
	if int(QLChk[QLn]) == QLtoken { /* valid shift */
		QLrcvr.char = -1
		QLtoken = -1
		QLVAL = QLrcvr.lval
		QLstate = QLn
		if Errflag > 0 {
			Errflag--
		}
		goto QLstack
	}

QLdefault:
	/* default state action */
	QLn = int(QLDef[QLstate])
	if QLn == -2 {
		if QLrcvr.char < 0 {
			QLrcvr.char, QLtoken = QLlex1(QLlex, &QLrcvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if QLExca[xi+0] == -1 && int(QLExca[xi+1]) == QLstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			QLn = int(QLExca[xi+0])
			if QLn < 0 || QLn == QLtoken {
				break
			}
		}
		QLn = int(QLExca[xi+1])
		if QLn < 0 {
			goto ret0
		}
	}
	if QLn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			QLlex.Error(QLErrorMessage(QLstate, QLtoken))
			Nerrs++
			if QLDebug >= 1 {
				__yyfmt__.Printf("%s", QLStatname(QLstate))
				__yyfmt__.Printf(" saw %s\n", QLTokname(QLtoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for QLp >= 0 {
				QLn = int(QLPact[QLS[QLp].yys]) + QLErrCode
				if QLn >= 0 && QLn < QLLast {
					QLstate = int(QLAct[QLn]) /* simulate a shift of "error" */
					if int(QLChk[QLstate]) == QLErrCode {
						goto QLstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if QLDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", QLS[QLp].yys)
				}
				QLp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if QLDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", QLTokname(QLtoken))
			}
			if QLtoken == QLEofCode {
				goto ret1
			}
			QLrcvr.char = -1
			QLtoken = -1
			goto QLnewstate /* try again in the same state */
		}
	}

	/* reduction by production QLn */
	if QLDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", QLn, QLStatname(QLstate))
	}

	QLnt := QLn
	QLpt := QLp
	_ = QLpt // guard against "declared and not used"

	QLp -= int(QLR2[QLn])
	// QLp is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if QLp+1 >= len(QLS) {
		nyys := make([]QLSymType, len(QLS)*2)
		copy(nyys, QLS)
		QLS = nyys
	}
	QLVAL = QLS[QLp+1]

	/* consult goto table to find next state */
	QLn = int(QLR1[QLn])
	QLg := int(QLPgo[QLn])
	QLj := QLg + QLS[QLp].yys + 1

	if QLj >= QLLast {
		QLstate = int(QLAct[QLg])
	} else {
		QLstate = int(QLAct[QLj])
		if int(QLChk[QLstate]) != -QLn {
			QLstate = int(QLAct[QLg])
		}
	}
	// dummy call; replaced with literal code
	switch QLnt {

	case 1:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:67
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 2:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:71
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 3:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:75
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 4:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:79
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 5:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:83
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 6:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:87
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 7:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:91
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 8:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:95
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 9:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:99
		{
			updateStmt(QLlex, QLDollar[1].stmt)
		}
	case 10:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:105
		{
			stmt := &SetStatement{}
			stmt.KVS = QLDollar[2].pairs
			QLVAL.stmt = stmt
		}
	case 11:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:113
		{
			stmt := &UseStatement{}
			if len(QLDollar[2].strslice) == 1 {
				stmt.DB = QLDollar[2].strslice[0]
				QLVAL.stmt = stmt
			} else if len(QLDollar[2].strslice) == 2 {
				stmt.DB = QLDollar[2].strslice[0]
				stmt.RP = QLDollar[2].strslice[1]
				QLVAL.stmt = stmt
			} else {
				QLlex.Error("namespace must be <db>.<rp>")
			}
		}
	case 12:
		QLDollar = QLS[QLpt-4 : QLpt+1]
//line parser.y:129
		{
			stmt := &InsertStatement{}
			stmt.LineProtocol = QLDollar[4].str

			if len(QLDollar[3].strslice) != 2 {
				QLlex.Error("namespace must be <db>.<rp>")
			} else {
				stmt.DB = QLDollar[3].strslice[0]
				stmt.RP = QLDollar[3].strslice[1]
				QLVAL.stmt = stmt
			}
		}
	case 13:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:142
		{
			stmt := &InsertStatement{}
			stmt.LineProtocol = QLDollar[2].str
			QLVAL.stmt = stmt
		}
	case 14:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:150
		{
			stmt := &ChunkedStatement{}
			QLVAL.stmt = stmt
		}
	case 15:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:157
		{
			stmt := &ChunkSizeStatement{}
			stmt.Size = QLDollar[2].integer
			QLVAL.stmt = stmt
		}
	case 16:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:165
		{
			QLVAL.integer = QLDollar[1].integer
		}
	case 17:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:171
		{
			stmt := &AuthStatement{}
			QLVAL.stmt = stmt
		}
	case 18:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:178
		{
			stmt := &HelpStatement{}
			QLVAL.stmt = stmt
		}
	case 19:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:185
		{
			stmt := &PrecisionStatement{}
			stmt.Precision = QLDollar[2].str
			QLVAL.stmt = stmt
		}
	case 20:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:193
		{
			stmt := &TimerStatement{}
			QLVAL.stmt = stmt
		}
	case 21:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:200
		{
			QLVAL.strslice = []string{QLDollar[1].str}
		}
	case 22:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:204
		{
			ns := []string{QLDollar[1].str}
			QLVAL.strslice = append(ns, QLDollar[3].strslice...)
		}
	case 23:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:211
		{
			QLVAL.str = QLDollar[1].str
		}
	case 24:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:215
		{
			QLVAL.str = QLDollar[1].str + " " + QLDollar[2].str
		}
	case 25:
		QLDollar = QLS[QLpt-4 : QLpt+1]
//line parser.y:221
		{
			QLVAL.str = QLDollar[1].str + QLDollar[2].str + QLDollar[3].str + " " + QLDollar[4].str
		}
	case 26:
		QLDollar = QLS[QLpt-2 : QLpt+1]
//line parser.y:225
		{
			QLVAL.str = QLDollar[1].str + " " + QLDollar[2].str
		}
	case 27:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:231
		{
			p := NewPair(QLDollar[1].str, QLDollar[3].str)
			QLVAL.pair = *p
		}
	case 28:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:236
		{
			p := NewPair(QLDollar[1].str, QLDollar[3].str)
			QLVAL.pair = *p
		}
	case 29:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:241
		{
			p := NewPair(QLDollar[1].str, QLDollar[3].integer)
			QLVAL.pair = *p
		}
	case 30:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:246
		{
			p := NewPair(QLDollar[1].str, QLDollar[3].decimal)
			QLVAL.pair = *p
		}
	case 31:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:253
		{
			QLVAL.pairs = Pairs{QLDollar[1].pair}
		}
	case 32:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:257
		{
			QLVAL.pairs = append(QLDollar[3].pairs, QLDollar[1].pair)
		}
	case 33:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:263
		{
			QLVAL.str = QLDollar[1].str
		}
	case 34:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:267
		{
			QLVAL.str = QLDollar[1].str + QLDollar[2].str + QLDollar[3].str
		}
	case 35:
		QLDollar = QLS[QLpt-3 : QLpt+1]
//line parser.y:273
		{
			QLVAL.str = QLDollar[1].str + QLDollar[2].str + QLDollar[3].str
		}
	case 36:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:279
		{
			QLVAL.str = QLDollar[1].str
		}
	case 37:
		QLDollar = QLS[QLpt-1 : QLpt+1]
//line parser.y:285
		{
			QLVAL.str = strconv.FormatInt(QLDollar[1].integer, 10)
		}
	}
	goto QLstack /* stack new state and value */
}
